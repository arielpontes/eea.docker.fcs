revision = '48d3fd1462da'
down_revision = '3b6b91477843'

from alembic import op
from flask_sqlalchemy import _SessionSignalEvents
import sqlalchemy as sa
from sqlalchemy import event
from sqlalchemy.dialects import mysql
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, Session as BaseSession, relationship

# Much of the code here is inspired by this:
#  - https://stackoverflow.com/questions/24612395/


Session = sessionmaker()


# The event.remove lines are to deal with Flask-SQLAlchemy. The extension adds
# some events to the session, but since the migration happens outside of the app
# context, these events produce exceptions.
event.remove(BaseSession, 'before_commit', _SessionSignalEvents.session_signal_before_commit)
event.remove(BaseSession, 'after_commit', _SessionSignalEvents.session_signal_after_commit)
event.remove(BaseSession, 'after_rollback', _SessionSignalEvents.session_signal_after_rollback)


Base = declarative_base()


# Create minimal versions of the classes to avoid clashes with other versions
# of the table
class BusinessProfile(Base):
    __tablename__ = 'businessprofile'

    id = sa.Column(sa.Integer, primary_key=True)
    highleveluses = sa.Column(sa.String(255))


class Undertaking(Base):
    __tablename__ = 'undertaking'

    id = sa.Column(sa.Integer, primary_key=True)
    domain = sa.Column(sa.String(32), nullable=False)
    businessprofile_id = sa.Column(sa.ForeignKey('businessprofile.id'))
    businessprofile = relationship('BusinessProfile')


def upgrade():

    bind = op.get_bind()
    session = Session(bind=bind)

    # Start schema migration

    ## Create many-to-many table based on UndertakingBusinessProfile class
    m2m_table = op.create_table(
        'undertaking_businessprofile',
        sa.Column('undertaking_id', sa.Integer(), nullable=True),
        sa.Column('businessprofile_id', sa.Integer(), nullable=True),
        sa.ForeignKeyConstraint(['businessprofile_id'], ['businessprofile.id'], ),
        sa.ForeignKeyConstraint(['undertaking_id'], ['undertaking.id'], ),
        mysql_engine='MyISAM'
    )

    m2m_values = []
    businessprofile_values = []
    businessprofile_id = 1

    # Perform data migration in order to preserve the data in columns to be
    # removed/changed
    for undertaking in session.query(Undertaking):
        if not undertaking.businessprofile:
            continue
        for profile in undertaking.businessprofile.highleveluses.split(','):
            businessprofile_values.append(
                {
                    'id': businessprofile_id,
                    'domain': undertaking.domain,
                    'highleveluses': profile
                }
            )
            m2m_values.append(
                {
                    'undertaking_id': undertaking.id,
                    'businessprofile_id': businessprofile_id
                }
            )
            businessprofile_id += 1

    session.query(BusinessProfile).delete()
    op.bulk_insert(BusinessProfile.__table__, businessprofile_values)
    op.bulk_insert(m2m_table, m2m_values)

    # Once the data is migrated, finish up the schema migration

    op.drop_column(u'undertaking', 'businessprofile_id')
    op.create_unique_constraint(None, 'user', ['username'])


def downgrade():
    # TODO: Add reverse data migration
    ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint(None, 'user')
    op.add_column(
        u'undertaking',
        sa.Column(
            'businessprofile_id',
            mysql.INTEGER(display_width=11),
            autoincrement=False,
            nullable=True
        )
    )
    op.drop_column(u'businessprofile', 'domain')
    op.drop_table('undertaking_businessprofile')
    ### end Alembic commands ###
